package com.ecom.apigateway.filter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpMethod;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import reactor.core.publisher.Mono;

@Component
public class RequestPreFilter implements GlobalFilter, Ordered {

	private static final Logger logger = LoggerFactory.getLogger(RequestPreFilter.class);

	@Override
	public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
		long startTime = System.currentTimeMillis();
		exchange.getAttributes().put("startTime", startTime);
		String path = exchange.getRequest().getURI().getPath();
		HttpMethod method = exchange.getRequest().getMethod();
		String ip = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
		logger.info("PRE FILTER â†’ {} {} | IP={}", method.toString(), path, ip);
		
// ---------------- RATE LIMIT ---------------- // 
//		if (!rateLimiter.allow(ip)) {
// return tooManyRequests(exchange);
//		}
// ---------------- JWT VALIDATION ----------------
//		String tokenWithBearer = exchange.getRequest().getHeaders().getFirst("Authorization");
//		if (tokenWithBearer != null && !path.contains("/authenticate/")) {
//			try {
//
//				String token = tokenWithBearer.replace("Bearer", "").trim();
//				Claims claims = Jwts.parserBuilder().setSigningKey(Keys.hmacShaKeyFor(decodedKey)).build()
//						.parseClaimsJws(token).getBody();
//				exchange.getAttributes().put("USER_ID", claims.get("USER_ID"));
//				exchange.getAttributes().put("ROLE_NAME", claims.get("ROLE_NAME"));
//				// ---------------- DECRYPT URI ----------------
//				String decryptedPart = aesUtil.decrypt(path);
//				exchange.getAttributes().put("DECRYPTED_URI", decryptedPart);
//			} catch (Exception e) {
//				return invalidToken(exchange, "Token is invalid or expired");
//			}
//		}
		return chain.filter(exchange);
	}
//
//	 private Mono<Void> tooManyRequests(ServerWebExchange exchange) {
//	        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
//	        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
//	        String body = """
//	                {
//	                  "status": 429,
//	                  "error": "Too Many Requests",
//	                  "message": "Rate limit exceeded. Try again later."
//	                }
//	                """;
//	        return exchange.getResponse()
//	                .writeWith(Mono.just(exchange.getResponse().bufferFactory().wrap(body.getBytes())));
//	    }
//
//	    private Mono<Void> invalidToken(ServerWebExchange exchange, String message) {
//	        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
//	        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
//	        String body = String.format("""
//	                {
//	                  "status": 401,
//	                  "error": "Unauthorized",
//	                  "message": "%s"
//	                }
//	                """, message);
//	        return exchange.getResponse()
//	                .writeWith(Mono.just(exchange.getResponse().bufferFactory().wrap(body.getBytes())));
//	    }

	@Override
	public int getOrder() {
		return -2; // run early
	}
}
